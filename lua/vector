#pragma once
#include <lua/types>
#include <lua/interp>

extern "C" {
    void *malloc(size_t);
    void free(void *);
}

namespace lua {
    template<typename T>
    class vector {
        T* _mem;
        size_t _size = 0;
        size_t _capacity = 0;
    public:
        using value_type = T;
        vector();
        ~vector();
        void push_back(const T);
        void resize();
        void pop_back();
        size_t size();
        T& operator[](size_t);
    };

    template<typename T>
    void vector<T>::push_back(const T v) {
        _size ++;
        resize();
        _mem[size()-1] = v;
    }
    template<typename T>
    void vector<T>::resize() {
        if (_size + 4 >= _capacity) {
            _capacity *= 2;
            T* newmem = (T*) malloc(sizeof(T) * _capacity);
            for (size_t i = 0; i < _size; i++) {
                newmem[i] = _mem[i];
            }
            free(_mem);
            _mem = newmem;
        }
    }

    template<typename T>
    size_t vector<T>::size() {
        return _size;
    }

    template<typename T>
    T& vector<T>::operator [](size_t ind) {
        return _mem[ind];
    }

    template<typename T>
    vector<T>::vector() {
        _capacity = 4;
        _mem = (T*) malloc(sizeof(T) * _capacity);
    }

    template<typename T>
    void vector<T>::pop_back() {
        _size --;
        // println(_size);
        _mem[_size].~T();
        // println(_size);
    }

    template<typename T>
    vector<T>::~vector() {
        while (_size > 0) {
            pop_back();
        }
        free(_mem);
    }
}