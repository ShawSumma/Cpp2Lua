#pragma once
#include <lua/cstddef>
#include <lua/numeric>
#include <lua/memory>

namespace std {
    template<typename>
    class vector;

    template<typename T>
    class vector {
        T* _mem;
        size_t _size = 0;
        size_t _capacity = 0;
    public:
        typedef T value_type;

        vector();
        vector(size_t);
        vector(size_t, size_t);
        vector(const vector<T> &);
        ~vector();
        void push_back(const T&);
        void resize();
        void pop_back();
        T *begin();
        T *end();
        size_t size();
        T &operator[](size_t);
    };

    template<typename T>
    void vector<T>::push_back(const T &v) {
        resize();
        _size ++;
        _mem[size()-1] = v;
    }

    template<typename T>
    T *vector<T>::begin() {
        return _mem;
    }

    template<typename T>
    T *vector<T>::end() {
        return _mem+_size;
    }

    template<typename T>
    void vector<T>::resize() {
        if (_size + 4 >= _capacity) {
            _capacity *= 2;
            T* newmem = (T*) malloc(sizeof(T) * _capacity);
            for (size_t i = 0; i < _size; i++) {
                newmem[i] = _mem[i];
            }
            free(_mem);
            _mem = newmem;
        }
    }

    template<typename T>
    size_t vector<T>::size() {
        return _size;
    }

    template<typename T>
    T &vector<T>::operator [](size_t ind) {
        return _mem[ind];
    }

    template<typename T>
    vector<T>::vector() {
        _capacity = 4;
        _mem = (T*) malloc(sizeof(T) * _capacity);
    }

    template<typename T>
    vector<T>::vector(size_t c, size_t v) {
        _capacity = c + 4;
        _size = c;
        _mem = (T*) malloc(sizeof(T) * _capacity);
        for (size_t i = 0; i < c; i++) {
            _mem[i] = v;
        }
    }

    template<typename T>
    vector<T>::vector(size_t c) {
        _capacity = c + 4;
        _size = c;
        _mem = (T*) malloc(sizeof(T) * _capacity);
    }

    template<typename T>
    vector<T>::vector(const vector<T> &vec) {
        _size = vec.size();
        _capacity = _size + 4;
        _mem = (T*) malloc(sizeof(T) * _capacity);
        for (size_t i = 0; i < _size; i++) {
            _mem[i] = vec[i];
        }
    }

    template<typename T>
    void vector<T>::pop_back() {
        _size --;
        _mem[_size].~T();
    }

    template<typename T>
    vector<T>::~vector() {
        while (_size > 0) {
            pop_back();
        }
        free(_mem);
    }
}