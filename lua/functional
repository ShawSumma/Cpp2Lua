#pragma once
#include <lua/memory>
#include <lua/cstddef>

#ifdef LUA_CPP_COMPILER 
namespace std {
    template <typename, typename...>
    class function;

    template<typename T, typename... Args>
    class _callable_base {
    public:
        virtual T operator()(Args...) = 0;
        virtual ~_callable_base();
    };

    template <typename F, typename T, typename... Args>
    class _callable_type : public _callable_base<T, Args...> {
        F _functor;
    public:
        _callable_type(F);
        virtual T operator()(Args...);
    };

    template <typename T, typename... Args>
    class function<T(Args...)> {
        std::unique_ptr<_callable_base<T, Args...>> _callable;
    public:
        template<typename F>
        function(F);
        function();
        template<typename F>
        function<T(Args...)> &operator=(F);
        T operator()(Args...);
    };

    template<typename T, typename... Args>
    _callable_base<T, Args...>::~_callable_base() {}

    template <typename F, typename T, typename... Args>
    _callable_type<F, T, Args...>::_callable_type(F functor) : _functor(functor) {}

    template <typename F, typename T, typename... Args>
    T _callable_type<F, T, Args...>::operator()(Args... args) {
        return _functor(args...);
    }

    template<typename T, typename... Args>
    template<typename F>
    function<T(Args...)>::function(F callable) {
        _callable.reset(new _callable_type<F, T, Args...>(callable));
    }

    template<typename T, typename... Args>
    template<typename F>
    function<T(Args...)> &function<T(Args...)>::operator=(F callable) {
        _callable.reset(new _callable_type<F, T, Args...>(callable));
        return *this;
    }

    template<typename T, typename... Args>
    function<T(Args...)>::function() {
        _callable.reset(nullptr);
    }

    template<typename T, typename... Args>
    T function<T(Args...)>::operator()(Args... args) {
        return (*_callable)(args...);
    }
}
#else
#include <functional>
#endif